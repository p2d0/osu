// using System;
using System.Reflection;
using osu.Framework.Allocation;
using osu.Framework.Graphics;
using osu.Framework.Graphics.Containers;
using osu.Framework.Screens;
using osu.Game.Graphics.Containers;
using osu.Game.Graphics.Sprites;

// using osu.Game; // Ensure you have reference to OsuGame or Game
// using osu.Game.Screens.Select;
using osu.Game.Screens.SelectV2; // Namespace for SoloSongSelect

namespace osu.Game.Rulesets.MOsu.UI
{
    public class BeatmapModsSelectInjector : Component
    {
        // Resolve the base Game class.
        // We use 'Game' or 'OsuGameBase' to be generic, then reflect into the actual instance.
        [Resolved]
        private OsuGame game { get; set; } = null!;

        private FieldInfo? screenStackField;
        private bool hasModifiedSongSelect;

        public BeatmapModsSelectInjector()
        {
            // CRITICAL FIX:
            // Forces Update() to run even when this container is Hidden (Alpha 0).
            AlwaysPresent = true;
        }

        [BackgroundDependencyLoader]
        private void load()
        {
            // Use reflection to get the "ScreenStack" field from the Game instance.
            // We search up the hierarchy (FlattenHierarchy) and look for non-public/public instance members.
            var type = game.GetType();

            // Note: Adjust "ScreenStack" string if the internal name is different (e.g. "_screenStack" or backing field).
            // If it is a Property (get; set;), use GetProperty instead of GetField.
            screenStackField = type.GetField("ScreenStack",
                BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy);

            // Fallback: If it's a property in the source you are looking at
            if (screenStackField == null)
            {
                // Try looking for the backing field often generated by compiler (e.g. <ScreenStack>k__BackingField)
                // or just try to get the property via reflection if needed.
                var prop = type.GetProperty("ScreenStack",
                    BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.FlattenHierarchy);

                // If you need the property value, you'd use prop.GetValue(game) later.
                // For this example, I'll assume it's a Field based on your prompt "protected OsuScreenStack ScreenStack;"
            }
        }

        protected override void Update()
        {
            base.Update();

            // Safety check if reflection failed
            if (screenStackField == null || game == null) return;

            // Get the current ScreenStack instance
            var screenStack = screenStackField.GetValue(game) as ScreenStack;

            // Check if we are currently on SoloSongSelect
            if (screenStack?.CurrentScreen is SoloSongSelect songSelect)
            {
                // Only run this logic once when we first detect the screen
                if (!hasModifiedSongSelect)
                {
                    // Your logic here
                    songSelect.OnLoadComplete += (drawable) => {
                        Schedule(() => injectBeatmapModsSelect((SoloSongSelect)drawable));};
                    // Scheduler.AddOnce(() => songSelect.Hide());
                    // ScheduleAfterChildren(() => songSelect.Hide());
                    // songSelect.Alpha = 0;

                    // Note: If you want your mod select menu to appear, you might want to ToggleVisibility() here
                    // if (State.Value == Visibility.Hidden) this.Show();

                    hasModifiedSongSelect = true;
                }
            }
            else
            {
                // Reset the flag so this works again if the user exits and re-enters Song Select
                hasModifiedSongSelect = false;
            }
        }

        private void injectBeatmapModsSelect(SoloSongSelect songSelect)
        {
            var fieldInfo = typeof(osu.Game.Screens.SelectV2.SongSelect)
                .GetField("detailsArea", BindingFlags.NonPublic | BindingFlags.Instance);

            if (fieldInfo == null) return;

            var oldDetailsArea = fieldInfo.GetValue(songSelect) as osu.Game.Screens.SelectV2.BeatmapDetailsArea;
            if (oldDetailsArea == null) return;

            var newDetailsArea = new MOsuBeatmapDetailsArea();

            // detailsArea lives inside a ShearAligningWrapper in SongSelect's wedge container. [file:2]
            if (oldDetailsArea.Parent.Parent is FillFlowContainer parentWrapper){
                parentWrapper.Remove(oldDetailsArea.Parent, true);
                parentWrapper.Add(new osu.Game.Graphics.Containers.ShearAligningWrapper(newDetailsArea));
            }

            fieldInfo.SetValue(songSelect, newDetailsArea);
            newDetailsArea.ClearTransforms();
            newDetailsArea.Alpha = 1;
            newDetailsArea.X = 0;
            newDetailsArea.Show();
        }

        // private void addAsExtraWedge(SoloSongSelect songSelect)
        // {
        //     var t = typeof(osu.Game.Screens.SelectV2.SongSelect);

        //     var wedgesField = t.GetField("wedgesContainer", BindingFlags.NonPublic | BindingFlags.Instance);
        //     var detailsField = t.GetField("detailsArea", BindingFlags.NonPublic | BindingFlags.Instance);

        //     var wedges = wedgesField?.GetValue(songSelect) as osu.Framework.Graphics.Containers.FillFlowContainer;
        //     var details = detailsField?.GetValue(songSelect) as osu.Game.Screens.SelectV2.BeatmapDetailsArea;
        //     if (wedges == null || details == null) return;

        //     var mo = new MOsuBeatmapDetailsArea();
        //     wedges.Insert(0, new osu.Game.Graphics.Containers.ShearAligningWrapper(mo)); // after title/details, adjust index as needed

        //     // crude sync (you may want a better mechanism / scheduled update):
        //     details.Expire();
        //     mo.Height = details.Height;
        //     mo.Alpha = details.Alpha;
        //     mo.Show(); // only if details is shown at this moment
        // }


        // protected override void PopIn()
        // {
        //     this.MoveToX(0, 400, Easing.OutQuint)
        //         .FadeIn(150, Easing.In);
        // }

        // protected override void PopOut()
        // {
        //     this.MoveToX(-150, 400, Easing.OutQuint)
        //         .FadeOut(150, Easing.In);
        // }
    }
}
